>新老用户：create database if not exists testSql;

use testSql;

drop table if exists fact_log;
CREATE TABLE fact_log (
user_id VARCHAR(50) NOT NULL, -- 用户ID
device_id VARCHAR(50) NOT NULL, -- 设备ID
login_date DATE NOT NULL, -- 登录日期
PRIMARY KEY (user_id, device_id, login_date) -- 主键，确保同一用户在同一天、同一设备上只记录一次
);


INSERT INTO fact_log (user_id, device_id, login_date)
VALUES
(1, 'device_1', '2025-08-01'),  -- 用户1首次登录
(2, 'device_2', '2025-08-01'),  -- 用户2首次登录
(1, 'device_1', '2025-08-02'),  -- 用户1非首次登录
(3, 'device_3', '2025-08-02'),  -- 用户3首次登录
(2, 'device_2', '2025-08-03');  -- 用户2非首次登录
select * from fact_log;

-- 求每天登录的新老用户数
SELECT
fl.login_date,
-- 新用户数：当天是该用户的首次登录
COUNT(CASE WHEN fl.login_date = ufl.first_login_date THEN 1 END) AS new_user_count,
-- 老用户数：登录日期在首次登录之后
COUNT(CASE WHEN fl.login_date > ufl.first_login_date THEN 1 END) AS old_user_count
FROM
fact_log fl
INNER JOIN (
-- 计算每个用户的首次登录日期
SELECT
user_id,
MIN(login_date) AS first_login_date
FROM
fact_log
GROUP BY
user_id
) ufl ON fl.user_id = ufl.user_id
GROUP BY
fl.login_date
ORDER BY
fl.login_date;
>#include <vector>
#include <unordered_map>

using namespace std;

class Solution {
public:
vector<int> twoSum(vector<int>& nums, int target) {
// 创建哈希表存储数字和其对应的索引
unordered_map<int, int> num_map;

        // 遍历数组
        for (int i = 0; i < nums.size(); ++i) {
            // 计算当前数字需要的互补数
            int complement = target - nums[i];
            
            // 检查互补数是否已经在哈希表中
            if (num_map.find(complement) != num_map.end()) {
                // 找到则返回两个索引
                return {num_map[complement], i};
            }
            
            // 未找到则将当前数字和索引存入哈希表
            num_map[nums[i]] = i;
        }
        
        // 题目保证有唯一解，这里只是为了满足函数返回要求
        return {};
    }
};